# Bad practices of dockerfile

#### 1. Использование latest версии

Проблема: использование такого тэга делает образ нестабильным, так как он всегда ссылается на последнюю доступную версию образа. Это может привести к непредсказуемому поведению приложения из-за изменений в обновлениях. Также стоит использовать slim-версии образов, например python:3.11-slim, чтобы сэкономить память в контейнере.

Решение: Явно указываем конкретные версии используемого ПО, по возможности используем slim-версии.

#### 2. Избыточное количество слоев

Проблема: Каждая команда Dockerfile создает отдельный слой, что увеличивает размер образа, а это в свою очередь влияет на производительность

Решение: Объединять команды, которые можно запустить в одном слое.

#### 3. Копирование ненужных файлов в образ

Проблема: Копирование всех находящихся по директории файлов зачастую не является обязательным, так как большинство файлов никак не влияют на работу сервиса, но при этом используют место в контейнере и создают ненужные зависимости.

Решение: Явно указывать пути до  конкретных используемых в работе контейнера файлов, не указывать директорию целиком и/или использование и занесение ненужных файлов в .dockerignore для исключения ненужных.

#### 4. Установка зависимостей без использования файлов с зависимостями

Проблема: Нет явного контроля версий библиотек, в случае обновлений библиотек может привести к ошибкам и другим непредсказуемым последствиям.

Решение: Использование файла requirements c явным указанием используемых библиотек и их версий

#### 5. Неиспользование кэширования Docker

Проблема: Если сначала устанавливать пакеты, а потом копировать исходники, кэширование Docker не будет эффективным, и при каждом изменении исходного кода установка пакетов будет выполняться снова.

Решение: Сначала нужно прописывать неизменяемые слои (например, установку пакетов), а уже затем скрипты, которые будут меняться.

#### 6. Прописанные явным образом в коде секреты и конфигурации

Проблема: Секреты и ключи могут попасть в репозиторий и стать уязвимыми.

Решение: Использовать переменные окружения или Docker Secrets.

# Плохие практики использования контейнеров в целом

### 1. Запуск контейнера под root пользователем

Проблема: Запуск приложения от root пользователя повышает риски информационной безопасности и могут привести к проблемам. Если контейнер будет скомпрометирован, атакующий получит полный доступ к хост-системе.

Решение: Создание отдельного пользователя для запуска контейнера и использование его по умолчанию.

### 2. Запуск нескольких процессов в одном контейнере

Запуск нескольких процессов в одном контейнере затрудняет управление и мониторинг. Рекомендуется создавать отдельный контейнер на каждый процесс. Это обеспечивает лучшую изоляцию и управление каждым процессом отдельно, например в случае нештатного завершения процесса. 

# Случаи, когда не стоит использовать контейнеры:

### 1. Легаси-приложения в монолитном формате:
Если имеются приложения-монолиты, которые уже работают на сервере и не требуют изменений или оптимизаций, они могут быть сложными для контейнеризации. Перенос таких приложений в контейнеры может потребовать неоправданно больших затрат сил и времени.

### 2. Приложения с большим перечнем зависимостей и библиотек
Если приложение требует установки большого количества библиотек, это может сделать образ слишком тяжелым и сложным в управлении в контейнере.

## Ответы на вопросы
### Можно ли ограничивать ресурсы (например, память или CPU) для сервисов в docker-compose.yml? Если нет, то почему, если да, то как?
Да, можно ограничивать ресурсы (даже делать лимит не только сверху, но и снизу).
```yaml
services:
  app:
    image: some_image
    deploy:
      resources:
        limits:
          cpus: '0.5'   # Ограничение сверху по количеству ядер
          memory: 512M  # Ограничение сверху по оперативной памяти
        reservations:
          cpus: '0.25'  # Ограничение снизу (столько минимально резервируется под этот сервис)
          memory: 256M  # Резерв оперативной памяти
```

### Как можно запустить только определенный сервис из docker-compose.yml, не запуская остальные?
`docker-compose up` поднимет нам все сервисы. Чтобы такого избежать, можно поднимать сервисы выборочно через прописывание в аргументах конкретных сервисов

```bash
docker-compose up service_name service_name2
```

# Start of docker containers

## Bad dockerfile practices
```bash
docker build -t bad-docker-airflow -f Dockerfile.bad .
docker run -p 8080:8080 -d bad-docker-airflow
```

## Good dockerfile practices
```bash
docker build -t good-docker-airflow -f Dockerfile.good .
docker run -d \
  -v $(pwd)/dags:/opt/airflow/dags \
  -v airflow-logs:/opt/airflow/logs \
  -p 8080:8080 \
  -e API_KEY="mysecretapikey" \
  good-docker-airflow
```
